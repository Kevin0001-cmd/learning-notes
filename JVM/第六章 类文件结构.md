# 第六章 类文件结构

## 6.1 概述

“计算机只认识0和1，所以我们写的程序需要被编译器翻译成由0和1构成的二进制格式才能被计算机执行。”把我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。

## 6.2 无关性基石

![](https://raw.githubusercontent.com/Kevin0001-cmd/picgo/main/202108192235618.png)

## 6.3 Class类文件结构

**Class文件是一组以8个字节为基础单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。 

根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：**“无符号数”和“表”**。后面的解析都要以这两种数据类型为基 础，所以这里笔者必须先解释清楚这两个概念。 

* **无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数**，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 
* **表是由多个无符号数或者其他表作为数据项构成的复合数据类型**，为了便于区分，所有表的命名 都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视 作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成。

### 6.3.1 魔数与Class文件的版本

> 魔数是什么？

每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。

使用魔数而不是扩展名来进行 识别主要是基于安全考虑，因为文件扩展名可以随意改动。

Class文件的魔数取得很有“浪漫气息”， 值为0xCAFEBABE（咖啡宝贝？）。

> Class文件的第5位到第8位分别是什么？

紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能 向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。

​															JDK版本与版本号的对应关系

![](https://raw.githubusercontent.com/Kevin0001-cmd/picgo/main/202108192242805.png)

### 6.3.2 常量池

## 6.4 字节码指令简介

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）
以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。

如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模 型来理解，这个执行模型虽然很简单，但依然可以有效正确地工作：

```
 do { 
     自动计算PC寄存器的值加1; 
     根据PC寄存器指示的位置，从字节码流中取出操作码; 
     if (字节码存在操作数) 从字节码流中取出操作数; 
     执行操作码所定义的操作; 
 } while (字节码流长度 > 0);
```

### 6.4.1 字节码与数据类型

​									表6-40 Java虚拟机指令集所支持的数据类型

![](https://raw.githubusercontent.com/Kevin0001-cmd/picgo/main/202108201128249.png)

![image-20210820112843340](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210820112843340.png)

编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为 相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类 似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来 处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类 型作为运算类型（Computational Type）来进行的。

### 6.4.2 加载和存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之 间来回传输，这类指令包括： 

* 将一个局部变量加载到操作栈：iload、`iload_<n>`、lload、`lload_<n>`、fload、`fload_<n>`、dload、 `dload_<n>`、aload、`aload__<n>` 
* 将一个数值从操作数栈存储到局部变量表：istore、`istore_<n>`、lstore、`lstore_<n>`、fstore、`fstore_<n>`、dstore、`dstore_<n>`、astore、`astore_<n>` 
* 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_ml、` iconst_<i>`、`lconst_<l>`、`fconst_<f>`、`dconst_ <d>`
* 扩充局部变量表的访问索引的指令：wide

### 6.4.3 算数指令

**算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。**

是不存在直接支持byte、short、char和boolean类型的算术指令，对于上述几种数据的运算，应使用操作int类型的指令代替。所有的算术指令包括：

* 加法指令：iadd、ladd、fadd、dadd
* 减法指令：isub、lsub、fsub、dsub
* 乘法指令：imul、lmul、fmul、dmul
* 除法指令：idiv、ldiv、fdiv、ddiv
* 求余指令：irem、lrem、frem、drem
* 取反指令：ineg、lneg、fneg、dneg
* 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
* 按位或指令：ior、lor
* 按位与指令：iand、land
* 按位异或指令：ixor、lwor
* 局部变量自增指令：iinc
* 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整型数运算场景都不应该抛出运行时异常。

### 6.4.4 类型转换指令

类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显 式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题。

 Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）： 

* int类型到long、float或者double类型 
* long类型到float、double类型 
* float类型到double类型 与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指 令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致 转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。



Java虚拟机将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，必须遵循以 下转换规则： 

* 如果浮点值是NaN，那转换结果就是int或long类型的0。 
* 如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在 目标类型T（int或long）的表示范围之类，那转换结果就是v；否则，将根据v的符号，转换为T所能表 示的最大或者最小正数。 

从double类型到float类型做窄化转换的过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍 入模式舍入得到一个可以使用float类型表示的数字。如果转换结果的绝对值太小、无法使用float来表 示的话，将返回float类型的正负零；如果转换结果的绝对值太大、无法使用float来表示的话，将返回 float类型的正负无穷大。对于double类型的NaN值将按规定转换为float类型的NaN值。 

尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是《Java虚拟机规 范》中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常

### 6.4.5 对象创建与访问指令

对象创建后，就可以通过对象访问指 令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括： 

* 创建类实例的指令：new 
* 创建数组的指令：newarray、anewarray、multianewarray 
* 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的 指令：getfield、putfield、getstatic、putstatic 
* 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload 
* 将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore 
* 取数组长度的指令：arraylength 
* 检查类实例类型的指令：instanceof、checkcast

### 6.4.5 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指 令，包括： 

* 将操作数栈的栈顶一个或两个元素出栈：pop、pop2 
* 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、 dup2_x1、dup_x2、dup2_x2 
* 将栈最顶端的两个数值互换：swap

### 6.4.7 控制转移指令

控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序，从概念模型上理解，可以认为**控制指令就是在有条件或无条件地修改PC寄存器的值**。控制转移指令包括： 

* 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne 
* 复合条件分支：tableswitch、lookupswitch 
* 无条件分支：goto、goto_w、jsr、jsr_w、ret 

在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明 显标识一个数据的值是否null，也有专门的指令用来检测null值。 

与前面算术运算的规则一致，对于boolean类型、byte类型、char类型和short类型的条件分支比较 操作，都使用int类型的比较指令来完成，而对于long类型、float类型和double类型的条件分支比较操 作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，见6.4.3节），运算 指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。 由于各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便、完善就显得尤为重 要，而Java虚拟机提供的int类型的条件分支指令是最为丰富、强大的

### 6.4.8 方法调用和返回指令

这里列举五条指令用于方法调用（具体在第8章讲解）： 

* invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）， 这也是Java语言中最常见的方法分派方式。 
* invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找 出适合的方法进行调用。 
* invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和 父类方法。 
* invokestatic指令：用于调用类静态方法（static方法）。 
* invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面 四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑 是由用户所设定的引导方法决定的。 

方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返 回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一 条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用

### 6.4.9 异常处理指令

在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛 出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常 状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出 ArithmeticException异常。 

而**在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和 ret指令来实现，现在已经不用了），而是采用异常表来完成**。

### 6.4.10 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管 程（Monitor，更常见的是直接将它称为“锁”）来实现的。 

方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟 机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为 同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如 果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成 还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取 到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同 步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。 

同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中 有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字 需要Javac编译器与Java虚拟机两者共同协作支持。

编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对 应的monitorexit指令，而无论这个方法是正常结束还是异常结束。

## 6.5 公有设计，私有实现

虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以 下两种： 

* 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集； 
* 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器 代码生成技术）。

## 6.6 Class文件结构的发展

Class文件结构一直处于一个相对比较稳定的状态，Class文件的主体结构、 字节码指令的语义和数量几乎没有出现过变动[1]，所有对Class文件格式的改进，都集中在访问标志、 属性表这些设计上原本就是可扩展的数据结构中添加新内容。

